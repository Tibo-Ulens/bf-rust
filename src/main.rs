//! TODO: make it better

#![feature(iterator_try_collect)]

use std::fs::File;
use std::io::{Read, Write};
use std::path::PathBuf;

use bf_rust::error::Error;
use bf_rust::instruction::{LinkedInstructions, UnlinkedInstructions};
use bf_rust::interpret::Interpreter;
use bf_rust::optimise::Optimisations;
use clap::{Arg, ArgAction, Command};

struct Config {
	input_path:    PathBuf,
	bytecode_path: Option<PathBuf>,
	optimisations: Optimisations,
}

/// Read all command line flags into a neat little struct
fn make_config() -> Result<Config, Error> {
	let matches = Command::new(env!("CARGO_PKG_NAME"))
		.version(env!("CARGO_PKG_VERSION"))
		.author(env!("CARGO_PKG_AUTHORS"))
		.about(env!("CARGO_PKG_DESCRIPTION"))
		.arg_required_else_help(true)
		.arg(
			Arg::new("emit_bytecode")
				.help("If set, emit bytecode instead of running the file")
				.short('b')
				.long("emit-bytecode")
				.action(ArgAction::SetTrue),
		)
		.arg(
			Arg::new("output_file")
				.help("The file to write the bytecode to")
				.short('p')
				.long("output")
				.action(ArgAction::Set),
		)
		.arg(
			Arg::new("optimisation")
				.help("Specify what optimisations to apply")
				.short('o')
				.long("optimise")
				.action(ArgAction::Set)
				.value_delimiter(',')
				.value_parser(["all", "combine-clears", "group-instructions"]),
		)
		.arg(Arg::new("file").help("The brainfuck file to run").index(1).required(true))
		.get_matches();

	// Unwrap is safe as file is required
	let input_path = PathBuf::from(matches.get_one::<String>("file").unwrap());

	let output_path_raw = matches.get_one::<String>("output_file").map(PathBuf::from);

	let opt_types: Vec<String> = match matches.get_many::<String>("optimisation") {
		Some(vals) => vals.cloned().collect(),
		None => vec![],
	};

	let bytecode_path = if matches.get_flag("emit_bytecode") {
		match output_path_raw {
			Some(p) => Some(p),
			None => {
				let mut original = input_path.clone();
				original.set_extension("bfc");
				Some(original)
			},
		}
	} else {
		None
	};

	Ok(Config { input_path, bytecode_path, optimisations: Optimisations::from_strings(&opt_types) })
}

/// Read and transpile brainfuck code, then optimise and run it
fn handle_file(bytes: &[u8], cfg: &Config) -> Result<(), Error> {
	let instructions = UnlinkedInstructions::from_text(bytes);

	let optimised_instructions = instructions.optimise(cfg.optimisations);
	let linked_instructions = optimised_instructions.link()?;

	if let Some(path) = &cfg.bytecode_path {
		let mut output_writer = File::create(path)?;
		let bytecode = linked_instructions.to_bytecode();

		output_writer.write_all(&bytecode)?;
		Ok(())
	} else {
		let mut interpreter = Interpreter::new(&linked_instructions);
		interpreter.run()
	}
}

/// Read and run pre-generated bytecode
fn handle_bytecode(bytes: &[u8], cfg: &Config) -> Result<(), Error> {
	let linked_instructions = LinkedInstructions::from_bytecode(bytes);

	if let Some(path) = &cfg.bytecode_path {
		let mut output_writer = File::create(path)?;
		let bytecode = linked_instructions.to_bytecode();

		output_writer.write_all(&bytecode)?;
		Ok(())
	} else {
		let mut interpreter = Interpreter::new(&linked_instructions);
		interpreter.run()
	}
}

fn run() -> Result<(), Error> {
	let config = make_config()?;

	let file = File::open(&config.input_path)?;
	let bytes: Vec<u8> = file.bytes().try_collect()?;

	let extension = match config.input_path.extension() {
		Some(ext) => ext.to_str().unwrap(),
		None => return Err(Error::UnknownFileExtension("".to_owned())),
	};

	if extension == "bf" {
		handle_file(&bytes, &config)
	} else if extension == "bfc" {
		handle_bytecode(&bytes, &config)
	} else {
		Err(Error::UnknownFileExtension(extension.to_owned()))
	}
}

fn main() {
	match run() {
		Ok(_) => (),
		Err(e) => eprintln!("{}", e),
	}
}
